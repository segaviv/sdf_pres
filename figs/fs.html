<html><body style="height:100%;width:100%;justify-content:center;display:flex"> <div style="height:100%;width:95%;display:flex"> <div style="height:100%;flex:auto;margin-right:20px"> <canvas style="height:100%;width:100%" id="canvas" class="canvas"> </canvas> </div> <div id="code" style="height:100%;width:50%"> <textarea rows="50" id="textarea" style="height:100%;width:100%">
      </textarea> </div> </div> </body><script>const autoUniformRegex=/\/\*([a-z\d]+)\*\/\s+([a-zA-Z\d]+)/g,codeElem=document.getElementById("code"),vsSource="attribute vec4 aVertexPosition; void main(){gl_Position = aVertexPosition;}",fsSource="\n    precision highp float;\n    uniform vec2 res;\n\n    void main() {\n      vec2 p = gl_FragCoord.xy - res / 2.;\n\n      gl_FragColor = vec4(vec3(clamp(length(p) / (res / 6.), 0., 1.)), 1.0);\n    }\n  ",canvas=document.getElementById("canvas");canvas.width=canvas.clientWidth,canvas.height=canvas.clientHeight;const gl=canvas.getContext("webgl"),input=document.getElementById("textarea");input.value=fsSource;let gShaderProgram=null,gBuffers=null,triggerCompilerTimeout=null,compilePromise=null;function initBuffers(e){const r=e.createBuffer();e.bindBuffer(e.ARRAY_BUFFER,r);return e.bufferData(e.ARRAY_BUFFER,new Float32Array([1,1,-1,1,1,-1,-1,-1]),e.STATIC_DRAW),{position:r}}function initShaderProgram(e,r,o){const t=loadShader(e,e.VERTEX_SHADER,r);if(null==t)return null;const n=loadShader(e,e.FRAGMENT_SHADER,o);if(null==n)return e.deleteShader(t),null;const a=e.createProgram();return e.attachShader(a,t),e.attachShader(a,n),e.linkProgram(a),e.deleteShader(t),e.deleteShader(n),e.getProgramParameter(a,e.LINK_STATUS)?a:(console.log("Unable to initialize the shader program: "+e.getProgramInfoLog(a)),e.deleteProgram(a),null)}function loadShader(e,r,o){const t=e.createShader(r);return e.shaderSource(t,o),e.compileShader(t),e.getShaderParameter(t,e.COMPILE_STATUS)?t:(console.log("An error occurred compiling the shaders: "+e.getShaderInfoLog(t)),e.deleteShader(t),null)}function drawScene(e,r,o,t){r.clearColor(0,0,0,1),r.clear(r.COLOR_BUFFER_BIT);{const e=2,n=r.FLOAT,a=!1,i=0,l=0;r.bindBuffer(r.ARRAY_BUFFER,t.position),r.vertexAttribPointer(o.attribLocations.vertexPosition,e,n,a,i,l),r.enableVertexAttribArray(o.attribLocations.vertexPosition)}r.useProgram(o.program),r.uniform2f(o.uniformLocations.res,e.width,e.height);{const e=0,o=4;r.drawArrays(r.TRIANGLE_STRIP,e,o)}}function init(){gShaderProgram=initShaderProgram(gl,vsSource,fsSource),gBuffers=initBuffers(gl);gl.getAttribLocation(gShaderProgram,"aVertexPosition"),gl.getUniformLocation(gShaderProgram,"res");compilePromise=compile()}async function compile(){const e=new Promise(((e,r)=>{const o=initShaderProgram(gl,vsSource,input.value);o||r(),e(o)}));return e.then((e=>{compilePromise=null,gl.deleteProgram(gShaderProgram),gShaderProgram=e;const r={program:gShaderProgram,attribLocations:{vertexPosition:gl.getAttribLocation(gShaderProgram,"aVertexPosition")},uniformLocations:{res:gl.getUniformLocation(gShaderProgram,"res")}};drawScene(canvas,gl,r,gBuffers)})),e}init(),input.oninput=()=>{triggerCompilerTimeout&&clearTimeout(triggerCompilerTimeout),setTimeout((()=>{compilePromise=compile()}),100)},window.addEventListener("keydown",(e=>{"Backquote"==e.code&&("none"==codeElem.style.display?codeElem.style.display="":codeElem.style.display="none")}));</script></html>