<html>

<body style="height: 100%; width: 100%; display: flex; justify-content: center;">
  <div id="uniform_editor" style="position: absolute; right: 20px; display: none;">
  </div>
  <div style="display: flex; height: 100%; width: 95%; ">
    <div style="height: 100%; flex:auto; margin-right: 20px;">
      <canvas style="height: 100%; width: 100%" id="canvas" class="canvas">
      </canvas>
    </div>
    <div id="code" style="height: 100%; width: 50%">
      <textarea rows="50" id="textarea" style="height: 100%; width: 100%">
      </textarea>
    </div>
  </div>
</body>

<script>

  const autoUniformRegex = /\/\*\s*([a-z\d]+)\s*\*\/\s*([a-zA-Z\d]+)/g;

  const codeElem = document.getElementById('code');
  const uniformEditor = document.getElementById('uniform_editor');
  const FLOAT_PRECISION = 'precision highp float;'
  const vsSource =
    "attribute vec4 aVertexPosition; void main(){gl_Position = aVertexPosition;}";

  const fsSource = `
    uniform vec2 res;

    void main() {
      vec2 p = gl_FragCoord.xy - res / 2.;

      gl_FragColor = vec4(1.0);
    }
  `;

  const AUTO_COMPILE_DELAY_MS = 100;

  const canvas = document.getElementById("canvas");
  canvas.width = canvas.clientWidth;
  canvas.height = canvas.clientHeight;
  const gl = canvas.getContext("webgl");
  const input = document.getElementById("textarea");
  input.value = fsSource;

  let bAutoCompile = false;
  let gShaderProgram = null;
  let gBuffers = null;
  let triggerCompilerTimeout = null;
  let compilePromise = null;
  let gUniforms = new Map();

  function initBuffers(gl) {
    const positionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    const positions = [1.0, 1.0, -1.0, 1.0, 1.0, -1.0, -1.0, -1.0];
    gl.bufferData(
      gl.ARRAY_BUFFER,
      new Float32Array(positions),
      gl.STATIC_DRAW
    );
    return { position: positionBuffer };
  }
  function initShaderProgram(gl, vsSource, fsSource) {
    const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);
    if (vertexShader == null) {
      return null;
    }
    const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);
    if (fragmentShader == null) {
      gl.deleteShader(vertexShader);
      return null;
    }
    const shaderProgram = gl.createProgram();
    gl.attachShader(shaderProgram, vertexShader);
    gl.attachShader(shaderProgram, fragmentShader);
    gl.linkProgram(shaderProgram);
    gl.deleteShader(vertexShader);
    gl.deleteShader(fragmentShader);
    if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
      console.log(
        "Unable to initialize the shader program: " +
        gl.getProgramInfoLog(shaderProgram)
      );
      gl.deleteProgram(shaderProgram);
      return null;
    }
    return shaderProgram;
  }
  function loadShader(gl, type, source) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
      console.log(
        "An error occurred compiling the shaders: " +
        gl.getShaderInfoLog(shader)
      );
      gl.deleteShader(shader);
      return null;
    }
    return shader;
  }
  function drawScene(canvas, gl, programInfo, buffers) {
    gl.clearColor(0.0, 0.0, 0.0, 1.0);
    gl.clear(gl.COLOR_BUFFER_BIT);

    {
      const numComponents = 2;
      const type = gl.FLOAT;
      const normalize = false;
      const stride = 0;
      const offset = 0;
      gl.bindBuffer(gl.ARRAY_BUFFER, buffers.position);
      gl.vertexAttribPointer(
        programInfo.attribLocations.vertexPosition,
        numComponents,
        type,
        normalize,
        stride,
        offset
      );
      gl.enableVertexAttribArray(programInfo.attribLocations.vertexPosition);
    }
    gl.useProgram(programInfo.program);
    gl.uniform2f(
      programInfo.uniformLocations.res,
      canvas.width,
      canvas.height
    );
    {
      const offset = 0;
      const vertexCount = 4;
      gl.drawArrays(gl.TRIANGLE_STRIP, offset, vertexCount);
    }
  }

  function init() {
    gBuffers = initBuffers(gl);
    compilePromise = compile();
  }

  init();

  function defaultValueForType(type) {
    switch (type) {
      case 'int':
        return 0;
      case 'float':
        return 0.0;
      case 'vec2':
        return [0.0, 0.0];
      case 'vec3':
        return [0.0, 0.0, 0.0];
      case 'vec4':
        return [0.0, 0.0, 0.0, 0.0];
    }
    return '';
  }

  function extractUniforms() {
    const uniforms = [...input.value.matchAll(autoUniformRegex)];
    const unfirmNames = new Set(uniforms.map(u => u[2]));
    // Remove uniforms that don't exist anymore.
    [...gUniforms.keys()]
      .filter(x => !unfirmNames.has(x)).forEach(u => gUniforms.delete(u));
    // Add new uniforms.
    uniforms.forEach(u => {
      if (!gUniforms.has(u) || gUniforms.get(u)['type'] != u[1])
      gUniforms.set(u[2], {type: u[1], value: defaultValueForType(u[1])});
    });
  }

  function getUniformString() {
    extractUniforms();
    let str = '';
    gUniforms.forEach((u, name) => {
      str += `uniform ${u.type} ${name};`;
    });
    return str;
  }

  /* Auto compile */
  input.oninput = () => {
    if (!bAutoCompile) {
      return;
    }
    if (triggerCompilerTimeout) {
      clearTimeout(triggerCompilerTimeout);
    }
    setTimeout(() => {
      compilePromise = compile();
    }, AUTO_COMPILE_DELAY_MS);
  };

  async function compile() {
    const res = new Promise((resolve, reject) => {
      const fShader = FLOAT_PRECISION + getUniformString() + input.value;
      const shaderProg = initShaderProgram(gl, vsSource, fShader);
      if (!shaderProg) {
        reject();
      }
      resolve(shaderProg);
    });
    res.then(newProgram => {
      compilePromise = null;
      gl.deleteProgram(gShaderProgram);
      gShaderProgram = newProgram;
      const programInfo = {
        program: gShaderProgram,
        attribLocations: {
          vertexPosition: gl.getAttribLocation(
            gShaderProgram,
            "aVertexPosition"
          ),
        },
        uniformLocations: {
          res: gl.getUniformLocation(gShaderProgram, "res"),
        },
      };
      drawScene(canvas, gl, programInfo, gBuffers);
    });
    return res;
  }

  window.addEventListener('keydown', (event) => {
    if (event.code == 'Backquote') {
      if (codeElem.style.display == 'none') {
        codeElem.style.display = '';
      } else {
        codeElem.style.display = 'none';
      }
    } else if (event.code == 'Enter' && event.ctrlKey) {
       compilePromise = compile();
    }
  });

</script>

</html>